//
//	Abstract
//

/*
	
	So goal is to have a filesystem based static site generator.

	To that end I need to:

		1) parse directory structure into site representation.					//check
			-need better per page/article configuration 						//check
		2) step through that and gen everything. 								//pages generating
		3) copy images, styles over 											//crawls for, moves over, down to one file depth
			-media query friendly image generation from originals
		4) less renderer, I mean. we've come this far
		4) blog listing
		5) tagging, now we're getting crazy 									//this is kind of happening, but i need a query method for it
		5) categories from directories?											//not categories, but sections, and is happening

	Without a blog, this is relatively easy, so, we'll start there I think.		//check

*/

var fs = require('fs');
var md = require('node-markdown').Markdown;
var jade = require('jade');
var util = require('util');

(function (root, factory) {
	if (typeof exports === 'object') {
		// Node. Does not work with strict CommonJS, but
		// only CommonJS-like enviroments that support module.exports,
		// like Node.
		module.exports = factory(global);
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define([], function () {
			return factory(root);
		});
	} else {
		// Browser globals
		factory(root);
	}
}(this, function (root) {
	"use strict";
	
	//get the execution path of the main script.

	var rootPath = require('path').dirname(require.main.filename);
	
	//object describing 
	var configuration;
	
	var initialized = false;

	var invalidFiles = ['.DS_Store','.git','.git_ignore'];

	var color = {
		red  : '\u001b[31m',
		green : '\u001b[32m',
		blue : '\u001b[34m',
		reset : '\u001b[0m',
	}

	function loadContent(){
		//get the stuff

		//this is in a weird spot. if pages isn't specified as a content type you don't get any pages generated, cause thats the top level content.
		//need a way to specify content type sitemap, so you can achieve things like a blogroll.

		//I could potentially leave that on the implementor, you could just use alligator to just parse everything into a content object you did you own render logic for.

		var obj = {
			
		};

		var contentTypesLength = configuration.contentTypes.length;
		
		for(var i = 0; i < contentTypesLength; i++){
			var secondary = fs.readdirSync(rootPath + "/" + configuration.contentTypes[i]);
			for(var ii = 0; ii < secondary.length; ii++){
				var a = contentObjectFromFile(secondary[ii],configuration.contentTypes[i])
				if(a) {
					if(!obj[configuration.contentTypes[i]]) obj[configuration.contentTypes[i]] = new Array();
					obj[configuration.contentTypes[i]].push(a);
				}
			}
		}
		
		return obj
	}

	function contentObjectFromFile(name,section){
		var valid = !contains(invalidFiles, name)
		if(valid){
			var file = fs.readFileSync(rootPath+"/"+section+"/"+name).toString();
			var time = fs.statSync(rootPath+"/"+section+"/"+name).ctime;

			var sections = file.split(':body')

			//added inline json object, could be used for tags and stuff, that sort of thing.
			var info = JSON.parse(sections[0]);
			info.title;
			var body = sections[1];
			
			var obj = {
				name:name.replace('.md',''),
				title:info.title,
				subTheme:(info.subTheme) ? info.subTheme : 'default',
				body: md(body.trim()),
				date: time
			}
			return obj
		}
	}

	function createNavList(obj){
		var nl = new Array();
		if(obj.pages){
			var pagesLength = obj.pages.length;
			for(var i = 0; i < pagesLength; i++){
				var n = (obj.pages[i].name == 'index') ? 'index.html' : obj.pages[i].name;
				var l = n.replace(' ','_');
				var navItem = {
					title:obj.pages[i].title,
					name:n,
					link:l,
				}
				navItem.html = "<a href='"+configuration.baseURL+navItem.link+"'>"+navItem.title+"</a>";
				nl.push(navItem);
			}
		} else {
			console.warn(color.red+"No Pages in Content Tree. Did you forget to add 'pages' to your configuration?"+color.reset);
		}
		return nl
	}

	function render(contentTree,navList){
		if(contentTree.pages){
			var pagesLength = contentTree.pages.length;
			for(var i = 0; i<pagesLength; i++){
				
				var path = rootPath + "/themes/" + configuration.themeDir + "/views/"+contentTree.pages[i].subTheme+".jade";
				jade.renderFile(path, {config:configuration,p:contentTree.pages[i],nav:navList,pretty:true},function(err,html){
					if(err){
						console.error('\nTheres something wrong with the template located at:');
						console.error(path);
						console.error('\n'+err + '\n');
					} else {
						saveRenderedHTML(html, contentTree.pages[i]);
					}
				});
			}
			//needs genericizing
			fetchAssets("images");
			fetchAssets("styles");
		} else {
			console.warn(color.red+"No Pages in Content Tree. No HTML will be generated. This is probably not what you wanted."+color.reset);
		}
	}

	function fetchAssets(section){
		fs.mkdir(rootPath + "/o/"+section+"/","0777",function(err){
			fileCrawl(rootPath + '/themes/' + configuration.themeDir + "/"+section, function(err,list){
				if(!err){
					list.forEach(function(item){
						var outP = rootPath + "/o" + item.replace(rootPath + '/themes/' + configuration.themeDir, '');
						var outName = outP.replace(/(\w*\/)+/,'');
						outP = outP.substring(0,outP.length - outName.length);
						if(outP.length > (rootPath + "/o/"+section).length){
							fs.mkdir(outP,"0777",function(err){
								copy(item,outP+outName);
							});
						} else {
							copy(item,outP+outName);
						}
					});
				}
			});
		});
	}

	function saveRenderedHTML(html,page){
		var oBuf = new Buffer(html);
		var name = (page.name == "index") ? "" : page.name + "/";
		var oPath = rootPath + "/o/" + name;
		var filePath = oPath + "index.html";
		fs.mkdir(oPath,"0777",function(err){
			if(err && err.code == 'EEXIST') console.log("Directory "+oPath+" already exists.");
			else if(err) throw('Error creating Directory '+ oPath)
			fs.open(filePath, 'w',function(err,file){
				if(err){
					console.error("\nCouldn't open file for output:");
					console.error(oPath);
					throw(err);
				} else {
					fs.write(file, oBuf, 0, oBuf.length, 0,function(err){
						if(err){
							console.error("\nCouldn't write to file:");
							console.error(oPath);
							throw(err);
						} else {
							console.log(color.green+'Successfully output '+oPath+color.reset)
						}
					});
				}
			});
		});
	}

	function copy(a,b){
		var is = fs.createReadStream(a);
		var os = fs.createWriteStream(b);
		util.pump(is, os);
	}
	function isValidConfiguration(c){
		//well, this is rudimentary, but there it is. this is where the better checking would go. hows that.
		if((typeof c.baseURL == 'string') && c.title && c.themeDir){
			return true;
		} else {
			return false;
		}
	}
	function contains(obj,str){
		for (var key in obj){
			if(obj[key] == str){
				return true
			}
		}
		return false
	}
	function generate(){
		if(initialized){
			var contentTree = loadContent();
			var navList = createNavList(contentTree);
			render(contentTree,navList);
		} else {
			throw("Call 'init' method with a valid configuration before calling 'generate'.");
		}
	}
	//thank you stackoverflow
	function fileCrawl(dir,done){
		var invalidForWatch = invalidFiles.slice(0,invalidFiles.length);
			invalidForWatch.push('o');
		var results = [];
		fs.readdir(dir, function(err, list) {
			if (err) return done(err);
				var pending = list.length;
				if (!pending) return done(null, results);
				list.forEach(function(file) {
				var valid = !contains(invalidForWatch, file)
				file = dir + '/' + file;
				if(valid){
					fs.stat(file, function(err, stat) {
						if (stat && stat.isDirectory()) {
							fileCrawl(file, function(err, res) {
								results = results.concat(res);
								if (!--pending) done(null, results);
							});
						} else {
							results.push(file);
							if (!--pending) done(null, results);
						}
					});
				} else {
					if (!--pending) done(null, results);
				}
			});
		});
	}
	return {
		init : function(c){
			if(isValidConfiguration(c)){
				configuration = c;
				initialized = true;
				return this
			} else {
				throw('Configuration Error');
			}
		},
		generate : function(){
			generate();
			return this
		},
		getContentTree : function(){
			if(initialized){
				var contentTree = loadContent();
				var navList = createNavList(contentTree);
				return contentTree;
			} else {
				throw("Call 'init' method with a valid configuration before calling 'getContentTree'.");
			}
		},
		watchMode : function(){
			console.log(color.green+'Running in watch mode. Changes to files in site directories should regenerate.'+color.reset)
			fileCrawl(rootPath,function(err,list){
				if(!err) {
					list.forEach(function(item){
						fs.watchFile(item,{ persistent: true, interval: 500 },function(err,f){
							console.log("File changed, regenning.")
							generate();
						});
					});
				}
			});
		}
	}
}));